{"version":3,"sources":["../src/index.js","../src/SpeechServices/SpeechToText/createSpeechRecognitionPonyfill.ts","../src/SpeechServices/patchOptions.ts","../src/SpeechServices/resolveFunctionOrReturnValue.ts","../src/SpeechServices/SpeechSDK.ts","../src/SpeechServices/SpeechToText/validation/credentialsSchema.ts","../src/SpeechServices/SpeechToText/validation/enableTelemetrySchema.ts","../src/SpeechServices/SpeechToText/validation/initialSilenceTimeoutSchema.ts","../src/SpeechServices/SpeechToText/validation/looseEventsSchema.ts","../src/SpeechServices/SpeechToText/validation/referenceGrammarsSchema.ts","../src/SpeechServices/SpeechToText/validation/speechRecognitionEndpointIdSchema.ts","../src/SpeechServices/SpeechToText/validation/textNormalizationSchema.ts","../src/SpeechServices/SpeechToText/createSpeechRecognitionPonyfillFromRecognizer.ts","../../../node_modules/p-defer/index.js","../src/Util/createPromiseQueue.js","../src/SpeechServices/SpeechToText/SpeechRecognitionAlternative.ts","../src/SpeechServices/SpeechToText/private/FakeArray.ts","../src/SpeechServices/SpeechToText/SpeechRecognitionResult.ts","../src/SpeechServices/SpeechToText/cognitiveServiceEventResultToWebSpeechRecognitionResult.ts","../src/SpeechServices/SpeechToText/cognitiveServicesAsyncToPromise.ts","../src/SpeechServices/SpeechToText/private/EventListenerMap.ts","../src/SpeechServices/SpeechToText/private/prepareAudioConfig.ts","../src/SpeechServices/SpeechToText/private/averageAmplitude.ts","../src/SpeechServices/SpeechToText/private/serializeRecognitionResult.ts","../src/SpeechServices/SpeechToText/SpeechGrammarList.ts","../src/SpeechServices/SpeechToText/SpeechRecognitionErrorEvent.ts","../src/SpeechServices/SpeechToText/SpeechRecognitionResultList.ts","../src/SpeechServices/SpeechToText/SpeechRecognitionEvent.ts","../src/SpeechServices/TextToSpeech/createSpeechSynthesisPonyfill.js","../src/SpeechServices/TextToSpeech/AudioContextQueue.js","../src/SpeechServices/TextToSpeech/AudioContextConsumer.js","../src/SpeechServices/TextToSpeech/SpeechSynthesisEvent.js","../src/SpeechServices/TextToSpeech/SpeechSynthesisUtterance.js","../src/SpeechServices/TextToSpeech/fetchSpeechData.js","../src/SpeechServices/TextToSpeech/buildSSML.js","../src/SpeechServices/TextToSpeech/isSSML.js","../src/SpeechServices/TextToSpeech/subscribeEvent.js","../src/SpeechServices/TextToSpeech/SpeechSynthesisVoice.js","../src/SpeechServices/TextToSpeech/fetchCustomVoices.js","../src/SpeechServices/TextToSpeech/fetchVoices.js","../src/SpeechServices/TextToSpeech.js","../src/SpeechServices/fetchAuthorizationToken.ts","../src/SpeechServices.ts"],"sourcesContent":["import createSpeechServicesPonyfill, {\n  createSpeechRecognitionPonyfill,\n  createSpeechRecognitionPonyfillFromRecognizer,\n  createSpeechSynthesisPonyfill,\n  fetchAuthorizationToken\n} from './SpeechServices';\n\nexport {\n  createSpeechRecognitionPonyfill,\n  createSpeechRecognitionPonyfillFromRecognizer,\n  createSpeechServicesPonyfill,\n  createSpeechSynthesisPonyfill,\n  fetchAuthorizationToken\n};\n","/* eslint class-methods-use-this: \"off\" */\n/* eslint complexity: [\"error\", 70] */\n/* eslint no-await-in-loop: \"off\" */\n/* eslint no-empty-function: \"off\" */\n/* eslint no-magic-numbers: [\"error\", { \"ignore\": [0, 100, 150] }] */\n\nimport { PropertyId } from 'microsoft-cognitiveservices-speech-sdk';\nimport patchOptions, { type PatchOptionsInit } from '../patchOptions';\nimport SpeechSDK from '../SpeechSDK';\nimport createSpeechRecognitionPonyfillFromRecognizer from './createSpeechRecognitionPonyfillFromRecognizer';\n\nconst { OutputFormat, SpeechConfig, SpeechRecognizer } = SpeechSDK;\n\nexport default function createSpeechRecognitionPonyfill(options: PatchOptionsInit) {\n  const {\n    audioConfig,\n    enableTelemetry,\n    fetchCredentials,\n    initialSilenceTimeout,\n    looseEvents,\n    referenceGrammars,\n    speechRecognitionEndpointId,\n    textNormalization\n  } = patchOptions(options);\n\n  if (!audioConfig && (!window.navigator.mediaDevices || !window.navigator.mediaDevices.getUserMedia)) {\n    throw new Error(\n      'web-speech-cognitive-services: This browser does not support Media Capture and Streams API and it will not work with Cognitive Services Speech Services.'\n    );\n  }\n\n  const createRecognizer = async (lang: string) => {\n    const credentials = await fetchCredentials();\n    let speechConfig;\n\n    if (typeof credentials.speechRecognitionHostname !== 'undefined') {\n      const host = new URL('wss://localhost:443');\n\n      host.hostname = credentials.speechRecognitionHostname;\n\n      if (credentials.authorizationToken) {\n        speechConfig = SpeechConfig.fromHost(host);\n        speechConfig.authorizationToken = credentials.authorizationToken;\n      } else {\n        speechConfig = SpeechConfig.fromHost(host, credentials.subscriptionKey);\n      }\n    } else {\n      speechConfig =\n        typeof credentials.authorizationToken !== 'undefined'\n          ? SpeechConfig.fromAuthorizationToken(credentials.authorizationToken, credentials.region)\n          : SpeechConfig.fromSubscription(credentials.subscriptionKey, credentials.region);\n    }\n\n    if (speechRecognitionEndpointId) {\n      speechConfig.endpointId = speechRecognitionEndpointId;\n    }\n\n    speechConfig.outputFormat = OutputFormat.Detailed;\n    speechConfig.speechRecognitionLanguage = lang || 'en-US';\n    typeof initialSilenceTimeout === 'number' &&\n      speechConfig.setProperty(PropertyId.SpeechServiceConnection_InitialSilenceTimeoutMs, '' + initialSilenceTimeout);\n\n    return new SpeechRecognizer(speechConfig, audioConfig);\n  };\n\n  return createSpeechRecognitionPonyfillFromRecognizer({\n    createRecognizer,\n    enableTelemetry,\n    looseEvents,\n    referenceGrammars,\n    textNormalization\n  });\n}\n","import { type AudioConfig as AudioConfigType } from 'microsoft-cognitiveservices-speech-sdk';\nimport { parse } from 'valibot';\n\nimport resolveFunctionOrReturnValue from './resolveFunctionOrReturnValue';\nimport SpeechSDK from './SpeechSDK';\nimport credentialsSchema, { type Credentials } from './SpeechToText/validation/credentialsSchema';\nimport enableTelemetrySchema, { EnableTelemetry } from './SpeechToText/validation/enableTelemetrySchema';\nimport initialSilenceTimeoutSchema, {\n  InitialSilenceTimeout\n} from './SpeechToText/validation/initialSilenceTimeoutSchema';\nimport looseEventsSchema, { LooseEvents } from './SpeechToText/validation/looseEventsSchema';\nimport referenceGrammarsSchema, { ReferenceGrammars } from './SpeechToText/validation/referenceGrammarsSchema';\nimport speechRecognitionEndpointIdSchema, {\n  SpeechRecognitionEndpointId\n} from './SpeechToText/validation/speechRecognitionEndpointIdSchema';\nimport textNormalizationSchema, { TextNormalization } from './SpeechToText/validation/textNormalizationSchema';\n\nconst { AudioConfig } = SpeechSDK;\n\nlet shouldWarnOnSubscriptionKey = true;\n\ntype PatchOptionsInit = {\n  audioConfig?: AudioConfigType | undefined;\n  credentials: (() => Credentials | Promise<Credentials>) | Credentials | Promise<Credentials>;\n  enableTelemetry?: boolean | undefined;\n  initialSilenceTimeout?: number | undefined;\n  looseEvent?: boolean | undefined;\n  looseEvents?: boolean | undefined;\n  referenceGrammars?: readonly string[] | undefined;\n  speechRecognitionEndpointId?: string | undefined;\n  textNormalization?: 'display' | 'itn' | 'lexical' | 'maskeditn' | undefined;\n};\n\ntype PatchedOptions = Readonly<{\n  audioConfig: AudioConfigType;\n  enableTelemetry: EnableTelemetry;\n  fetchCredentials: () => Promise<Credentials>;\n  initialSilenceTimeout: InitialSilenceTimeout;\n  looseEvents: LooseEvents;\n  referenceGrammars: ReferenceGrammars;\n  speechRecognitionEndpointId: SpeechRecognitionEndpointId;\n  textNormalization: TextNormalization;\n}>;\n\nexport default function patchOptions(init: PatchOptionsInit): PatchedOptions {\n  const {\n    audioConfig,\n    credentials,\n    enableTelemetry,\n    initialSilenceTimeout,\n    looseEvent,\n    referenceGrammars,\n    speechRecognitionEndpointId,\n    textNormalization\n  } = init;\n\n  let { looseEvents } = init;\n\n  if (typeof looseEvent !== 'undefined') {\n    console.warn('web-speech-cognitive-services: The option \"looseEvent\" should be named as \"looseEvents\".');\n\n    looseEvents = looseEvent;\n  }\n\n  return Object.freeze({\n    audioConfig: audioConfig || AudioConfig.fromDefaultMicrophoneInput(),\n    // We set telemetry to true to honor the default telemetry settings of Speech SDK\n    // https://github.com/Microsoft/cognitive-services-speech-sdk-js#data--telemetry\n    enableTelemetry: parse(enableTelemetrySchema, enableTelemetry),\n    fetchCredentials: async () => {\n      const parsedCredentials = parse(credentialsSchema, await resolveFunctionOrReturnValue<Credentials>(credentials));\n\n      if (shouldWarnOnSubscriptionKey && parsedCredentials.subscriptionKey) {\n        console.warn(\n          'web-speech-cognitive-services: In production environment, subscription key should not be used, authorization token should be used instead.'\n        );\n\n        shouldWarnOnSubscriptionKey = false;\n      }\n\n      return parsedCredentials;\n    },\n    initialSilenceTimeout: parse(initialSilenceTimeoutSchema, initialSilenceTimeout),\n    looseEvents: parse(looseEventsSchema, looseEvents),\n    referenceGrammars: parse(referenceGrammarsSchema, referenceGrammars),\n    speechRecognitionEndpointId: parse(speechRecognitionEndpointIdSchema, speechRecognitionEndpointId),\n    textNormalization: parse(textNormalizationSchema, textNormalization)\n  });\n}\n\nexport type { Credentials, PatchedOptions, PatchOptionsInit };\n","function isFunction(value: unknown): value is () => unknown {\n  return typeof value === 'function';\n}\n\nexport default function resolveFunctionOrReturnValue<T>(\n  fnOrValue: (() => Promise<T> | T) | Promise<T> | T\n): Promise<T> | T {\n  return isFunction(fnOrValue) ? fnOrValue() : fnOrValue;\n}\n","// We are only importing what we need.\n\nimport {\n  AudioConfig,\n  OutputFormat,\n  ResultReason,\n  SpeechConfig,\n  SpeechRecognizer\n} from 'microsoft-cognitiveservices-speech-sdk/distrib/lib/microsoft.cognitiveservices.speech.sdk';\n\nexport default {\n  AudioConfig,\n  OutputFormat,\n  ResultReason,\n  SpeechConfig,\n  SpeechRecognizer\n};\n","import { type InferOutput, intersect, object, optional, pipe, readonly, string, undefined_, union } from 'valibot';\n\nconst credentialsSchema = pipe(\n  intersect([\n    union(\n      [\n        object({\n          authorizationToken: string(),\n          subscriptionKey: optional(undefined_('\"subscriptionKey\" must be unset when \"authorizationToken\" is set.'))\n        }),\n        object({\n          authorizationToken: optional(undefined_('\"authorizationToken\" must be unset when \"subscriptionKey\" is set.')),\n          subscriptionKey: string()\n        })\n      ],\n      'The object must either have either \"authorizationToken\" or \"subscriptionKey\" set, but not both.'\n    ),\n    union(\n      [\n        object({\n          customVoiceHostname: optional(undefined_('\"customVoiceHostname\" must be unest when \"region\" is set.')),\n          region: string(),\n          speechRecognitionHostname: optional(\n            undefined_('\"speechRecognitionHostname\" must be unest when \"region\" is set.')\n          ),\n          speechSynthesisHostname: optional(undefined_('\"speechSynthesisHostname\" must be unest when \"region\" is set.'))\n        }),\n        object({\n          customVoiceHostname: optional(union([string(), undefined_()])),\n          region: optional(undefined_('\"region\" must be unset when \"*Hostname\" is set.')),\n          speechRecognitionHostname: string(),\n          speechSynthesisHostname: string()\n        })\n      ],\n      'The object must either have either \"region\" or \"*Hostname\" set, but not both.'\n    )\n  ]),\n  readonly()\n);\n\nexport default credentialsSchema;\n\nexport type Credentials = InferOutput<typeof credentialsSchema>;\n","import { boolean, type InferOutput, optional } from 'valibot';\n\nconst enableTelemetrySchema = optional(boolean());\n\nexport type EnableTelemetry = InferOutput<typeof enableTelemetrySchema>;\n\nexport default enableTelemetrySchema;\n","import { type InferOutput, maxValue, minValue, number, optional, pipe } from 'valibot';\n\n// 60_000 is an arbitrary value, we can set it to a larger number.\nconst initialSilenceTimeoutSchema = optional(pipe(number(), minValue(1), maxValue(60_000)));\n\nexport type InitialSilenceTimeout = InferOutput<typeof initialSilenceTimeoutSchema>;\n\nexport default initialSilenceTimeoutSchema;\n","import { type InferOutput, boolean, optional } from 'valibot';\n\nconst looseEventsSchema = optional(boolean(), false);\n\nexport type LooseEvents = InferOutput<typeof looseEventsSchema>;\n\nexport default looseEventsSchema;\n","import { array, type InferOutput, optional, pipe, string, transform } from 'valibot';\n\nconst referenceGrammarsSchema = pipe(\n  optional(array(string()), []),\n  // any(),\n  // array(string()),\n  // transform<string[], readonly string[]>(value => (Object.isFrozen(value) ? value : Object.freeze([...value])))\n  transform<string[], readonly string[]>(value => (Object.isFrozen(value) ? value : Object.freeze([...value])))\n);\n\nexport type ReferenceGrammars = InferOutput<typeof referenceGrammarsSchema>;\n\nexport default referenceGrammarsSchema;\n","import { type InferOutput, optional, string } from 'valibot';\n\nconst speechRecognitionEndpointIdSchema = optional(string());\n\nexport type SpeechRecognitionEndpointId = InferOutput<typeof speechRecognitionEndpointIdSchema>;\n\nexport default speechRecognitionEndpointIdSchema;\n","import { type InferOutput, enum_, optional } from 'valibot';\n\nconst textNormalizationSchema = optional(\n  enum_({\n    display: 'display',\n    itn: 'itn',\n    lexical: 'lexical',\n    maskeditn: 'maskeditn'\n  }),\n  'display'\n);\n\nexport type TextNormalization = InferOutput<typeof textNormalizationSchema>;\n\nexport default textNormalizationSchema;\n","/* eslint class-methods-use-this: \"off\" */\n/* eslint complexity: [\"error\", 70] */\n/* eslint no-await-in-loop: \"off\" */\n/* eslint no-empty-function: \"off\" */\n/* eslint no-magic-numbers: [\"error\", { \"ignore\": [0, 100, 150] }] */\n\nimport {\n  type CancellationEventArgs,\n  type RecognitionEventArgs,\n  type SessionEventArgs,\n  type SpeechRecognitionEventArgs,\n  type SpeechRecognizer as SpeechRecognizerType\n} from 'microsoft-cognitiveservices-speech-sdk';\nimport { type AudioConfigImpl } from 'microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioConfig';\nimport { boolean, function_, parse, undefined_, union } from 'valibot';\nimport createPromiseQueue from '../../Util/createPromiseQueue';\nimport SpeechSDK from '../SpeechSDK';\nimport cognitiveServiceEventResultToWebSpeechRecognitionResult from './cognitiveServiceEventResultToWebSpeechRecognitionResult';\nimport cognitiveServicesAsyncToPromise from './cognitiveServicesAsyncToPromise';\nimport EventListenerMap from './private/EventListenerMap';\nimport prepareAudioConfig from './private/prepareAudioConfig';\nimport serializeRecognitionResult from './private/serializeRecognitionResult';\nimport SpeechGrammarList from './SpeechGrammarList';\nimport SpeechRecognitionErrorEvent from './SpeechRecognitionErrorEvent';\nimport SpeechRecognitionEvent from './SpeechRecognitionEvent';\nimport { type SpeechRecognitionEventListenerMap } from './SpeechRecognitionEventListenerMap';\nimport type SpeechRecognitionResult from './SpeechRecognitionResult';\nimport SpeechRecognitionResultList from './SpeechRecognitionResultList';\nimport referenceGrammarsSchema from './validation/referenceGrammarsSchema';\nimport textNormalizationSchema from './validation/textNormalizationSchema';\n\n// https://docs.microsoft.com/en-us/javascript/api/microsoft-cognitiveservices-speech-sdk/speechconfig?view=azure-node-latest#outputformat\n// {\n//   \"RecognitionStatus\": \"Success\",\n//   \"Offset\": 900000,\n//   \"Duration\": 49000000,\n//   \"NBest\": [\n//     {\n//       \"Confidence\": 0.738919,\n//       \"Lexical\": \"second\",\n//       \"ITN\": \"second\",\n//       \"MaskedITN\": \"second\",\n//       \"Display\": \"Second.\"\n//     }\n//   ]\n// }\n\n// {\n//   \"RecognitionStatus\": \"InitialSilenceTimeout\",\n//   \"Offset\": 50000000,\n//   \"Duration\": 0\n// }\n\nconst { ResultReason, SpeechRecognizer } = SpeechSDK;\n\ntype CreateSpeechRecognitionPonyfillFromRecognizerInit = {\n  createRecognizer: (lang: string) => Promise<SpeechRecognizerType>;\n  enableTelemetry: boolean | undefined;\n  looseEvents: boolean;\n  referenceGrammars?: readonly string[] | undefined;\n  textNormalization: 'display' | 'itn' | 'lexical' | 'maskeditn';\n};\n\nconst enableTelemetrySchema = union([boolean(), undefined_()]);\n\nexport default function createSpeechRecognitionPonyfillFromRecognizer({\n  createRecognizer,\n  enableTelemetry,\n  looseEvents,\n  referenceGrammars,\n  textNormalization\n}: CreateSpeechRecognitionPonyfillFromRecognizerInit) {\n  createRecognizer = parse(function_(), createRecognizer) as typeof createRecognizer;\n  enableTelemetry = parse(enableTelemetrySchema, enableTelemetry);\n  looseEvents = parse(boolean(), looseEvents);\n  referenceGrammars = parse(referenceGrammarsSchema, referenceGrammars);\n  textNormalization = parse(textNormalizationSchema, textNormalization);\n\n  // If enableTelemetry is set to null or non-boolean, we will default to true.\n  typeof enableTelemetry !== 'undefined' && SpeechRecognizer.enableTelemetry(enableTelemetry);\n\n  class SpeechRecognition extends EventTarget {\n    #continuous = false;\n    #eventListenerMap: SpeechRecognitionEventListenerMap = new EventListenerMap(this);\n    #grammars: SpeechGrammarList = new SpeechGrammarList();\n    #interimResults = false;\n    #lang =\n      typeof window !== 'undefined'\n        ? window.document.documentElement.getAttribute('lang') || window.navigator.language\n        : 'en-US';\n    // eslint-disable-next-line no-magic-numbers\n    #maxAlternatives: number = 1;\n\n    emitCognitiveServices<T extends { type: string }>(type: string, event: T) {\n      this.dispatchEvent(\n        new SpeechRecognitionEvent('cognitiveservices', {\n          data: {\n            ...event,\n            type\n          }\n        })\n      );\n    }\n\n    get continuous(): boolean {\n      return this.#continuous;\n    }\n\n    set continuous(value: boolean) {\n      this.#continuous = value;\n    }\n\n    get grammars(): SpeechGrammarList {\n      return this.#grammars;\n    }\n\n    set grammars(value: SpeechGrammarList) {\n      if (value instanceof SpeechGrammarList) {\n        this.#grammars = value;\n      } else {\n        throw new Error(`The provided value is not of type 'SpeechGrammarList'`);\n      }\n    }\n\n    get interimResults() {\n      return this.#interimResults;\n    }\n\n    set interimResults(value) {\n      this.#interimResults = value;\n    }\n\n    get maxAlternatives() {\n      return this.#maxAlternatives;\n    }\n\n    set maxAlternatives(value) {\n      this.#maxAlternatives = value;\n    }\n\n    get lang() {\n      return this.#lang;\n    }\n\n    set lang(value) {\n      this.#lang = value;\n    }\n\n    get onaudioend(): ((event: SpeechRecognitionEvent<'audioend'>) => void) | undefined {\n      return this.#eventListenerMap.getProperty('audioend');\n    }\n\n    set onaudioend(value: ((event: SpeechRecognitionEvent<'audioend'>) => void) | undefined) {\n      this.#eventListenerMap.setProperty('audioend', value);\n    }\n\n    /** @type { ((event: SpeechRecognitionEvent<'audiostart'>) => void) | undefined } */\n    get onaudiostart() {\n      return this.#eventListenerMap.getProperty('audiostart');\n    }\n\n    set onaudiostart(\n      /** @type { ((event: SpeechRecognitionEvent<'audiostart'>) => void) | undefined } */\n      value\n    ) {\n      this.#eventListenerMap.setProperty('audiostart', value);\n    }\n\n    /** @type { ((event: SpeechRecognitionEvent<'cognitiveservices'>) => void) | undefined } */\n    get oncognitiveservices() {\n      return this.#eventListenerMap.getProperty('cognitiveservices');\n    }\n\n    set oncognitiveservices(\n      /** @type { ((event: SpeechRecognitionEvent<'cognitiveservices'>) => void) | undefined } */\n      value\n    ) {\n      this.#eventListenerMap.setProperty('cognitiveservices', value);\n    }\n\n    /** @type { ((event: SpeechRecognitionEvent<'end'>) => void) | undefined } */\n    get onend() {\n      return this.#eventListenerMap.getProperty('end');\n    }\n\n    set onend(\n      /** @type { ((event: SpeechRecognitionEvent<'end'>) => void) | undefined } */\n      value\n    ) {\n      this.#eventListenerMap.setProperty('end', value);\n    }\n\n    /** @type { ((event: SpeechRecognitionErrorEvent) => void) | undefined } */\n    get onerror() {\n      return this.#eventListenerMap.getProperty('error');\n    }\n\n    set onerror(\n      /** @type { ((event: SpeechRecognitionErrorEvent) => void) | undefined } */\n      value\n    ) {\n      this.#eventListenerMap.setProperty('error', value);\n    }\n\n    /** @type { ((event: SpeechRecognitionEvent<'result'>) => void) | undefined } */\n    get onresult() {\n      return this.#eventListenerMap.getProperty('result');\n    }\n\n    set onresult(\n      /** @type { ((event: SpeechRecognitionEvent<'result'>) => void) | undefined } */\n      value\n    ) {\n      this.#eventListenerMap.setProperty('result', value);\n    }\n\n    /** @type { ((event: SpeechRecognitionEvent<'soundend'>) => void) | undefined } */\n    get onsoundend() {\n      return this.#eventListenerMap.getProperty('soundend');\n    }\n\n    set onsoundend(\n      /** @type { ((event: SpeechRecognitionEvent<'soundend'>) => void) | undefined } */\n      value\n    ) {\n      this.#eventListenerMap.setProperty('soundend', value);\n    }\n\n    /** @type { ((event: SpeechRecognitionEvent<'soundstart'>) => void) | undefined } */\n    get onsoundstart() {\n      return this.#eventListenerMap.getProperty('soundstart');\n    }\n\n    set onsoundstart(\n      /** @type { ((event: SpeechRecognitionEvent<'soundstart'>) => void) | undefined } */\n      value\n    ) {\n      this.#eventListenerMap.setProperty('soundstart', value);\n    }\n\n    /** @type { ((event: SpeechRecognitionEvent<'speechend'>) => void) | undefined } */\n    get onspeechend() {\n      return this.#eventListenerMap.getProperty('speechend');\n    }\n\n    set onspeechend(\n      /** @type { ((event: SpeechRecognitionEvent<'speechend'>) => void) | undefined } */\n      value\n    ) {\n      this.#eventListenerMap.setProperty('speechend', value);\n    }\n\n    /** @type { ((event: SpeechRecognitionEvent<'speechstart'>) => void) | undefined } */\n    get onspeechstart() {\n      return this.#eventListenerMap.getProperty('speechstart');\n    }\n\n    set onspeechstart(\n      /** @type { ((event: SpeechRecognitionEvent<'speechstart'>) => void) | undefined } */\n      value\n    ) {\n      this.#eventListenerMap.setProperty('speechstart', value);\n    }\n\n    /** @type { ((event: SpeechRecognitionEvent<'start'>) => void) | undefined } */\n    get onstart() {\n      return this.#eventListenerMap.getProperty('start');\n    }\n\n    set onstart(\n      /** @type { ((event: SpeechRecognitionEvent<'start'>) => void) | undefined } */\n      value\n    ) {\n      this.#eventListenerMap.setProperty('start', value);\n    }\n\n    abort: (() => void) | undefined;\n    stop: (() => void) | undefined;\n\n    start() {\n      this._startOnce().catch(err => {\n        this.dispatchEvent(\n          new SpeechRecognitionErrorEvent('error', { error: err, message: err && (err.stack || err.message) })\n        );\n      });\n    }\n\n    async _startOnce() {\n      // TODO: [P2] Should check if recognition is active, we should not start recognition twice\n      const recognizer = await createRecognizer(this.lang);\n\n      const { pause, unprepare } = prepareAudioConfig(recognizer['audioConfig']);\n\n      try {\n        const queue = createPromiseQueue();\n        let soundStarted;\n        let speechStarted;\n        let stopping;\n\n        const { detach: detachAudioConfigEvent } = (recognizer['audioConfig'] as AudioConfigImpl).events.attach(\n          event => {\n            const { name } = event;\n\n            if (name === 'AudioSourceReadyEvent') {\n              queue.push({ audioSourceReady: {} });\n            } else if (name === 'AudioSourceOffEvent') {\n              queue.push({ audioSourceOff: {} });\n            } else if (name === 'FirstAudibleChunk') {\n              queue.push({ firstAudibleChunk: {} });\n            }\n          }\n        );\n\n        recognizer.canceled = (_, { errorDetails, offset, reason, sessionId }: CancellationEventArgs) => {\n          queue.push({\n            canceled: {\n              errorDetails,\n              offset,\n              reason,\n              sessionId\n            }\n          });\n        };\n\n        recognizer.recognized = (_, { offset, result, sessionId }: SpeechRecognitionEventArgs) => {\n          queue.push({\n            recognized: {\n              offset,\n              result: serializeRecognitionResult(result),\n              sessionId\n            }\n          });\n        };\n\n        recognizer.recognizing = (_, { offset, result, sessionId }: SpeechRecognitionEventArgs) => {\n          queue.push({\n            recognizing: {\n              offset,\n              result: serializeRecognitionResult(result),\n              sessionId\n            }\n          });\n        };\n\n        recognizer.sessionStarted = (_, { sessionId }: SessionEventArgs) => {\n          queue.push({ sessionStarted: { sessionId } });\n        };\n\n        recognizer.sessionStopped = (_, { sessionId }: SessionEventArgs) => {\n          // \"sessionStopped\" is never fired, probably because we are using startContinuousRecognitionAsync instead of recognizeOnceAsync.\n          queue.push({ sessionStopped: { sessionId } });\n        };\n\n        recognizer.speechStartDetected = (_, { offset, sessionId }: RecognitionEventArgs) => {\n          queue.push({ speechStartDetected: { offset, sessionId } });\n        };\n\n        recognizer.speechEndDetected = (_, { sessionId }: RecognitionEventArgs) => {\n          // \"speechEndDetected\" is never fired, probably because we are using startContinuousRecognitionAsync instead of recognizeOnceAsync.\n          // Update: \"speechEndDetected\" is fired for DLSpeech.listenOnceAsync()\n          queue.push({ speechEndDetected: { sessionId } });\n        };\n\n        const { phrases } = this.grammars;\n\n        // HACK: We are using the internal of SpeechRecognizer because they did not expose it\n        const { dynamicGrammar } = recognizer['privReco'];\n\n        referenceGrammars && referenceGrammars.length && dynamicGrammar.addReferenceGrammar([...referenceGrammars]);\n        phrases && phrases.length && dynamicGrammar.addPhrase([...phrases]);\n\n        await cognitiveServicesAsyncToPromise<void>(recognizer.startContinuousRecognitionAsync, recognizer)();\n\n        if (typeof recognizer.stopContinuousRecognitionAsync === 'function') {\n          this.abort = () => queue.push({ abort: {} });\n          this.stop = () => queue.push({ stop: {} });\n        } else {\n          this.abort = this.stop = undefined;\n        }\n\n        let audioStarted;\n        let finalEvent: SpeechRecognitionErrorEvent | SpeechRecognitionEvent<'result'> | undefined = undefined;\n        let finalizedResults: readonly SpeechRecognitionResult[] = [];\n\n        for (let loop = 0; !stopping || audioStarted; loop++) {\n          const event = await queue.shift();\n          const {\n            abort,\n            audioSourceOff,\n            audioSourceReady,\n            canceled,\n            firstAudibleChunk,\n            recognized,\n            recognizing,\n            stop\n          } = event;\n\n          // We are emitting event \"cognitiveservices\" for debugging purpose.\n          Object.keys(event).forEach(name => this.emitCognitiveServices(name, event[name]));\n\n          const errorMessage = canceled && canceled.errorDetails;\n\n          if (/Permission\\sdenied/u.test(errorMessage || '')) {\n            // If microphone is not allowed, we should not emit \"start\" event.\n\n            finalEvent = new SpeechRecognitionErrorEvent('error', { error: 'not-allowed' });\n\n            break;\n          }\n\n          if (!loop) {\n            this.dispatchEvent(new SpeechRecognitionEvent('start'));\n          }\n\n          if (errorMessage) {\n            if (/1006/u.test(errorMessage)) {\n              if (!audioStarted) {\n                this.dispatchEvent(new SpeechRecognitionEvent('audiostart'));\n                this.dispatchEvent(new SpeechRecognitionEvent('audioend'));\n              }\n\n              finalEvent = new SpeechRecognitionErrorEvent('error', { error: 'network' });\n            } else {\n              finalEvent = new SpeechRecognitionErrorEvent('error', { error: 'unknown' });\n            }\n\n            break;\n          } else if (abort || stop) {\n            if (abort) {\n              finalEvent = new SpeechRecognitionErrorEvent('error', { error: 'aborted' });\n\n              // If we are aborting, we will ignore lingering recognizing/recognized events. But if we are stopping, we need them.\n              stopping = 'abort';\n            } else {\n              // When we pause, we will send { isEnd: true }, Speech Services will send us \"recognized\" event.\n              pause();\n              stopping = 'stop';\n            }\n\n            // Abort should not be dispatched without support of \"stopContinuousRecognitionAsync\".\n            // But for defensive purpose, we make sure \"stopContinuousRecognitionAsync\" is available before we can call.\n            if (abort && recognizer.stopContinuousRecognitionAsync) {\n              await cognitiveServicesAsyncToPromise<void>(recognizer.stopContinuousRecognitionAsync, recognizer)();\n            }\n          } else if (audioSourceReady) {\n            this.dispatchEvent(new SpeechRecognitionEvent('audiostart'));\n\n            audioStarted = true;\n          } else if (firstAudibleChunk) {\n            this.dispatchEvent(new SpeechRecognitionEvent('soundstart'));\n\n            soundStarted = true;\n          } else if (audioSourceOff) {\n            // Looks like we don't need this line and all the tests are still working.\n            // Guessing probably stopping is already truthy.\n            // stopping = true;\n\n            speechStarted && this.dispatchEvent(new SpeechRecognitionEvent('speechend'));\n            soundStarted && this.dispatchEvent(new SpeechRecognitionEvent('soundend'));\n            audioStarted && this.dispatchEvent(new SpeechRecognitionEvent('audioend'));\n\n            audioStarted = soundStarted = speechStarted = false;\n\n            break;\n          } else if (stopping !== 'abort') {\n            if (recognized && recognized.result && recognized.result.reason === ResultReason.NoMatch) {\n              // Quirks: 2024-11-19 with Speech SDK 1.41.0\n              //   When microphone is muted, `reason` is `NoMatch` (0) in both interactive mode and continuous mode.\n              //   After receiving this \"recognized but no match\" event, both modes will continue to recognize speech with \"speechStartDetected\" and \"recognizing\" events.\n              //   That means, we need to end this manually in interactive mode, and continuous-but-stopping mode.\n              if (!this.continuous || stopping === 'stop') {\n                // Empty result will turn into \"no-speech\" later in the code.\n                finalEvent = new SpeechRecognitionEvent('result', {\n                  results: new SpeechRecognitionResultList(finalizedResults)\n                });\n\n                // Quirks: 2024-11-19 with Speech SDK 1.14.0\n                //   Speech SDK did not stop after NoMatch even in interactive mode.\n                recognizer.stopContinuousRecognitionAsync &&\n                  (await cognitiveServicesAsyncToPromise<void>(\n                    recognizer.stopContinuousRecognitionAsync,\n                    recognizer\n                  )());\n\n                // Quirks: 2024-11-19 with Speech SDK 1.14.0\n                //   After calling stopContinuousRecognitionAsync, no \"audioSourceOff\" is fired.\n\n                break;\n              }\n            } else if (recognized || recognizing) {\n              if (!audioStarted) {\n                // Unconfirmed prevention of quirks\n                this.dispatchEvent(new SpeechRecognitionEvent('audiostart'));\n\n                audioStarted = true;\n              }\n\n              if (!soundStarted) {\n                this.dispatchEvent(new SpeechRecognitionEvent('soundstart'));\n\n                soundStarted = true;\n              }\n\n              if (!speechStarted) {\n                this.dispatchEvent(new SpeechRecognitionEvent('speechstart'));\n\n                speechStarted = true;\n              }\n\n              if (recognized) {\n                const result = cognitiveServiceEventResultToWebSpeechRecognitionResult(recognized.result, {\n                  maxAlternatives: this.maxAlternatives,\n                  textNormalization\n                });\n\n                const recognizable = !!result[0]?.transcript;\n\n                if (recognizable) {\n                  finalizedResults = [...finalizedResults, result];\n\n                  this.continuous &&\n                    this.dispatchEvent(\n                      new SpeechRecognitionEvent('result', {\n                        results: new SpeechRecognitionResultList(finalizedResults)\n                      })\n                    );\n                }\n\n                // If it is continuous, we just sent the finalized results. So we don't need to send it again after \"audioend\" event.\n                if (this.continuous && recognizable) {\n                  finalEvent = undefined;\n                } else {\n                  finalEvent = new SpeechRecognitionEvent('result', {\n                    results: new SpeechRecognitionResultList(finalizedResults)\n                  });\n                }\n\n                // If it is interactive, stop after first recognition.\n                // If it is continuous and it is stopping, stop it too.\n                if ((!this.continuous || stopping === 'stop') && recognizer.stopContinuousRecognitionAsync) {\n                  await cognitiveServicesAsyncToPromise<void>(recognizer.stopContinuousRecognitionAsync, recognizer)();\n                }\n\n                // If event order can be loosened, we can send the recognized event as soon as we receive it.\n                // 1. If it is not recognizable (no-speech), we should send an \"error\" event just before \"end\" event. We will not loosen \"error\" events.\n                if (looseEvents && finalEvent && recognizable) {\n                  this.dispatchEvent(finalEvent);\n                  finalEvent = undefined;\n                }\n              } else if (recognizing) {\n                this.interimResults &&\n                  this.dispatchEvent(\n                    new SpeechRecognitionEvent('result', {\n                      results: new SpeechRecognitionResultList([\n                        ...finalizedResults,\n                        cognitiveServiceEventResultToWebSpeechRecognitionResult(recognizing.result, {\n                          maxAlternatives: this.maxAlternatives,\n                          textNormalization\n                        })\n                      ])\n                    })\n                  );\n              }\n            }\n          }\n        }\n\n        if (speechStarted) {\n          this.dispatchEvent(new SpeechRecognitionEvent('speechend'));\n        }\n\n        if (soundStarted) {\n          this.dispatchEvent(new SpeechRecognitionEvent('soundend'));\n        }\n\n        if (audioStarted) {\n          this.dispatchEvent(new SpeechRecognitionEvent('audioend'));\n        }\n\n        if (finalEvent) {\n          if (finalEvent.type === 'result' && !finalEvent.results.length) {\n            finalEvent = new SpeechRecognitionErrorEvent('error', { error: 'no-speech' });\n          }\n\n          this.dispatchEvent(finalEvent);\n        }\n\n        // Even though there is no \"start\" event emitted, we will still emit \"end\" event\n        // This is mainly for \"microphone blocked\" story.\n        this.dispatchEvent(new SpeechRecognitionEvent('end'));\n\n        detachAudioConfigEvent();\n      } catch (err) {\n        // Logging out the erorr because Speech SDK would fail silently.\n        console.error(err);\n\n        throw err;\n      } finally {\n        unprepare();\n        recognizer['dispose'](false);\n      }\n    }\n  }\n\n  return {\n    SpeechGrammarList,\n    SpeechRecognition,\n    SpeechRecognitionEvent\n  };\n}\n","export default function pDefer() {\n\tconst deferred = {};\n\n\tdeferred.promise = new Promise((resolve, reject) => {\n\t\tdeferred.resolve = resolve;\n\t\tdeferred.reject = reject;\n\t});\n\n\treturn deferred;\n}\n","import createDeferred from 'p-defer';\n\nexport default function () {\n  let shiftDeferred;\n  const queue = [];\n\n  const push = value => {\n    if (shiftDeferred) {\n      const { resolve } = shiftDeferred;\n\n      shiftDeferred = null;\n      resolve(value);\n    } else {\n      queue.push(value);\n    }\n  };\n\n  const shift = () => {\n    if (queue.length) {\n      return Promise.resolve(queue.shift());\n    }\n\n    return (shiftDeferred || (shiftDeferred = createDeferred())).promise;\n  };\n\n  return {\n    push,\n    shift\n  };\n}\n","export type SpeechRecognitionAlternativeInit = {\n  confidence: number;\n  transcript: string;\n};\n\nexport default class SpeechRecognitionAlternative {\n  constructor({ confidence, transcript }: SpeechRecognitionAlternativeInit) {\n    this.#confidence = confidence;\n    this.#transcript = transcript;\n  }\n\n  #confidence: number;\n  #transcript: string;\n\n  get confidence() {\n    return this.#confidence;\n  }\n\n  get transcript() {\n    return this.#transcript;\n  }\n}\n","interface FakeArrayInterface<T> {\n  [index: number]: T | undefined;\n  get length(): number;\n}\n\nexport default class FakeArray<T> implements FakeArrayInterface<T> {\n  constructor(array: readonly T[]) {\n    if (!array) {\n      throw new Error('array must be set.');\n    }\n\n    this.#array = array;\n\n    for (const key in array) {\n      Object.defineProperty(this, key, {\n        enumerable: true,\n        get() {\n          return array[key];\n        }\n      });\n    }\n  }\n\n  #array: readonly T[];\n  [index: number]: T | undefined;\n  [Symbol.iterator]() {\n    return this.#array[Symbol.iterator]();\n  }\n\n  get length(): number {\n    return this.#array.length;\n  }\n}\n","import FakeArray from './private/FakeArray';\n\nexport type SpeechRecognitionResultInit = {\n  isFinal: boolean;\n  results: readonly SpeechRecognitionAlternative[];\n};\n\nexport default class SpeechRecognitionResult extends FakeArray<SpeechRecognitionAlternative> {\n  constructor(init: SpeechRecognitionResultInit) {\n    super(init.results);\n\n    this.#isFinal = init.isFinal;\n  }\n\n  #isFinal: boolean;\n\n  get isFinal(): boolean {\n    return this.#isFinal;\n  }\n}\n","import SpeechSDK from '../SpeechSDK';\n\nimport SpeechRecognitionAlternative from './SpeechRecognitionAlternative';\nimport SpeechRecognitionResult from './SpeechRecognitionResult';\nimport type { SerializedRecognitionResult } from './private/serializeRecognitionResult';\n\nconst {\n  ResultReason: { RecognizingSpeech, RecognizedSpeech }\n} = SpeechSDK;\n\nexport default function (\n  result: SerializedRecognitionResult,\n  init?:\n    | {\n        maxAlternatives: number;\n        textNormalization: 'display' | 'itn' | 'lexical' | 'maskeditn';\n      }\n    | undefined\n): SpeechRecognitionResult {\n  const { maxAlternatives = Infinity, textNormalization = 'display' } = init || {};\n  const json: {\n    NBest: readonly {\n      Confidence: number;\n      Display: string;\n      ITN: string;\n      Lexical: string;\n      MaskedITN: string;\n    }[];\n  } = typeof result.json === 'string' ? JSON.parse(result.json) : result.json;\n\n  if (result.reason === RecognizingSpeech || (result.reason === RecognizedSpeech && !json.NBest)) {\n    return new SpeechRecognitionResult({\n      isFinal: result.reason === RecognizedSpeech,\n      results: [\n        new SpeechRecognitionAlternative({\n          confidence: 0.5,\n          transcript: result.text\n        })\n      ]\n    });\n  } else if (result.reason === RecognizedSpeech) {\n    return new SpeechRecognitionResult({\n      isFinal: true,\n      results: (json.NBest || []).slice(0, maxAlternatives).map(\n        ({ Confidence: confidence, Display: display, ITN: itn, Lexical: lexical, MaskedITN: maskedITN }) =>\n          new SpeechRecognitionAlternative({\n            confidence,\n            transcript:\n              textNormalization === 'itn'\n                ? itn\n                : textNormalization === 'lexical'\n                  ? lexical\n                  : textNormalization === 'maskeditn'\n                    ? maskedITN\n                    : display\n          })\n      )\n    });\n  }\n\n  return new SpeechRecognitionResult({ isFinal: false, results: [] });\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nexport default function cognitiveServicesAsyncToPromise<\n  R,\n  T extends (resolve: (returnValue: R) => void, reject: (error: unknown) => void) => void = (\n    resolve: (returnValue: R) => void,\n    reject: (error: unknown) => void\n  ) => void\n>(fn: T, context?: undefined | unknown): () => Promise<R>;\n\nexport default function cognitiveServicesAsyncToPromise<\n  R,\n  P0 = any,\n  T extends (arg0: P0, resolve: (returnValue: R) => void, reject: (error: unknown) => void) => void = (\n    arg0: P0,\n    resolve: (returnValue: R) => void,\n    reject: (error: unknown) => void\n  ) => void\n>(fn: T, context?: undefined | unknown): (arg0: P0) => Promise<R>;\n\nexport default function cognitiveServicesAsyncToPromise<\n  R,\n  P0 = any,\n  P1 = any,\n  T extends (arg0: P0, arg1: P1, resolve: (returnValue: R) => void, reject: (error: unknown) => void) => void = (\n    arg0: P0,\n    arg1: P1,\n    resolve: (returnValue: R) => void,\n    reject: (error: unknown) => void\n  ) => void\n>(fn: T, context?: undefined | unknown): (arg0: P0, arg1: P1) => Promise<R>;\n\nexport default function cognitiveServicesAsyncToPromise<\n  R,\n  P0 = any,\n  P1 = any,\n  P2 = any,\n  T extends (\n    arg0: P0,\n    arg1: P1,\n    arg2: P2,\n    resolve: (returnValue: R) => void,\n    reject: (error: unknown) => void\n  ) => void = (\n    arg0: P0,\n    arg1: P1,\n    arg2: P2,\n    resolve: (returnValue: R) => void,\n    reject: (error: unknown) => void\n  ) => void\n>(fn: T, context?: undefined | unknown): (arg0: P0, arg1: P1, arg2: P2) => Promise<R>;\n\nexport default function cognitiveServicesAsyncToPromise<\n  R,\n  P0 = any,\n  P1 = any,\n  P2 = any,\n  P3 = any,\n  T extends (\n    arg0: P0,\n    arg1: P1,\n    arg2: P2,\n    arg3: P3,\n    resolve: (returnValue: R) => void,\n    reject: (error: unknown) => void\n  ) => void = (\n    arg0: P0,\n    arg1: P1,\n    arg2: P2,\n    arg3: P3,\n    resolve: (returnValue: R) => void,\n    reject: (error: unknown) => void\n  ) => void\n>(fn: T, context?: undefined | unknown): (arg0: P0, arg1: P1, arg2: P2, arg3: P3) => Promise<R>;\n\nexport default function cognitiveServicesAsyncToPromise<\n  R,\n  T extends (...args: any[]) => void = (...args: any[]) => void\n>(fn: T, context: undefined | unknown = undefined): (...args: Parameters<T>) => Promise<R> {\n  return (...args: Parameters<T>) =>\n    // eslint-disable-next-line prefer-spread\n    new Promise<R>((resolve, reject) => fn.apply(context, [...args, resolve, reject] as unknown as Parameters<T>));\n}\n","type EventListener<T> = (event: T) => void;\n\nexport default class EventListenerMap<T extends string, EventMap extends { [Name in T]: unknown }> {\n  constructor(eventTarget: EventTarget) {\n    this.#eventTarget = eventTarget;\n    this.#propertyMap = {};\n  }\n\n  #eventTarget: EventTarget;\n  #propertyMap: { [Name in keyof EventMap]?: EventListener<EventMap[Name]> | undefined };\n\n  getProperty<U extends T>(name: U): ((event: EventMap[U]) => void) | undefined {\n    return this.#propertyMap[name];\n  }\n\n  setProperty<U extends T>(name: U, value: ((event: EventMap[U]) => void) | undefined) {\n    const existing = this.#propertyMap[name];\n\n    existing && this.#eventTarget.removeEventListener(name, existing as EventListener<Event>);\n\n    if (value) {\n      this.#eventTarget.addEventListener(name, value as EventListener<Event>);\n    }\n\n    this.#propertyMap[name] = value;\n  }\n}\n","import { AudioSourceEvent } from 'microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/AudioSourceEvents';\nimport {\n  type AudioConfig,\n  type AudioConfigImpl\n} from 'microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioConfig';\nimport averageAmplitude from './averageAmplitude';\n\nexport default function prepareAudioConfig(audioConfig: AudioConfig) {\n  // Speech SDK also force cast AudioConfig to AudioConfigImpl and pass it to ServiceRecognizerBase to use attach() and other methods.\n  // https://github.com/microsoft/cognitive-services-speech-sdk-js/blob/a6e9d2a202534565ccc97650861a6b296de48ecf/src/sdk/SpeechRecognizer.ts#L291C27-L291C43\n  const audioConfigImpl = audioConfig as AudioConfigImpl;\n  const originalAttach = audioConfigImpl.attach;\n  const boundOriginalAttach = audioConfigImpl.attach.bind(audioConfigImpl);\n  let firstChunk = false;\n  let muted = false;\n\n  // We modify \"attach\" function and detect when audible chunk is read.\n  // We will only modify \"attach\" function once.\n  audioConfigImpl.attach = async () => {\n    const reader = await boundOriginalAttach('');\n\n    return {\n      ...reader,\n      read: async () => {\n        const chunk = await reader.read();\n\n        // The magic number 150 is measured by:\n        // 1. Set microphone volume to 0\n        // 2. Observe the amplitude (100-110) for the first few chunks\n        //    (There is a short static caught when turning on the microphone)\n        // 3. Set the number a bit higher than the observation\n        if (!firstChunk && averageAmplitude(chunk.buffer) > 150) {\n          audioConfigImpl.events.onEvent(new AudioSourceEvent('FirstAudibleChunk', ''));\n          firstChunk = true;\n        }\n\n        if (muted) {\n          return { buffer: new ArrayBuffer(0), isEnd: true, timeReceived: Date.now() };\n        }\n\n        return chunk;\n      }\n    };\n  };\n\n  return {\n    audioConfig,\n    pause: () => {\n      muted = true;\n    },\n    unprepare: () => {\n      audioConfigImpl.attach = originalAttach;\n    }\n  };\n}\n","export default function averageAmplitude(arrayBuffer: ArrayBuffer): number {\n  const array = Array.from(new Int16Array(arrayBuffer));\n\n  return array.reduce((averageAmplitude, amplitude) => averageAmplitude + Math.abs(amplitude), 0) / array.length;\n}\n","import { type SpeechRecognitionResult } from 'microsoft-cognitiveservices-speech-sdk';\n\nexport type SerializedRecognitionResult = Readonly<{\n  duration: number;\n  errorDetails: string;\n  json: unknown;\n  offset: number;\n  properties: unknown;\n  reason: number;\n  resultId: string;\n  text: string;\n}>;\n\nexport default function serializeRecognitionResult({\n  duration,\n  errorDetails,\n  json,\n  offset,\n  properties,\n  reason,\n  resultId,\n  text\n}: SpeechRecognitionResult): SerializedRecognitionResult {\n  return Object.freeze({\n    duration,\n    errorDetails,\n    json: json && JSON.parse(json),\n    offset,\n    properties,\n    reason,\n    resultId,\n    text\n  });\n}\n","interface W3CSpeechGrammar {\n  src: string;\n  weight: number;\n}\n\ninterface W3CSpeechGrammarList {\n  readonly length: number;\n  addFromString(string: string, weight?: number): void;\n  addFromURI(src: string, weight?: number): void;\n  item(index: number): W3CSpeechGrammar;\n  [index: number]: W3CSpeechGrammar;\n}\n\n/* eslint class-methods-use-this: \"off\" */\n\nexport default class SpeechGrammarList implements W3CSpeechGrammarList {\n  constructor() {\n    this.#phrases = [];\n  }\n\n  addFromString() {\n    throw new Error('JSGF is not supported');\n  }\n\n  addFromURI() {\n    throw new Error('JSGF is not supported');\n  }\n\n  item(): W3CSpeechGrammar {\n    throw new Error('JSGF is not supported');\n  }\n\n  get length(): number {\n    throw new Error('JSGF is not supported');\n  }\n\n  [index: number]: { src: string; weight: number };\n\n  #phrases: readonly string[];\n\n  get phrases(): readonly string[] {\n    return this.#phrases;\n  }\n\n  set phrases(value: readonly string[]) {\n    if (Array.isArray(value)) {\n      this.#phrases = Object.freeze([...value]);\n    } else if (typeof value === 'string') {\n      this.#phrases = Object.freeze([value]);\n    } else {\n      throw new Error(`The provided value is not an array or of type 'string'`);\n    }\n  }\n}\n","export type SpeechRecognitionErrorType =\n  | 'aborted'\n  | 'audio-capture'\n  | 'bad-grammar'\n  | 'language-not-supported'\n  | 'network'\n  | 'no-speech'\n  | 'not-allowed'\n  | 'service-not-allowed'\n  | 'unknown';\n\nexport type SpeechRecognitionErrorEventInit = {\n  error: SpeechRecognitionErrorType;\n  message?: string | undefined;\n};\n\nexport default class SpeechRecognitionErrorEvent extends Event {\n  constructor(type: 'error', { error, message }: SpeechRecognitionErrorEventInit) {\n    super(type);\n\n    this.#error = error;\n    this.#message = message;\n  }\n\n  #error: SpeechRecognitionErrorType;\n  #message: string | undefined;\n\n  get error(): SpeechRecognitionErrorType {\n    return this.#error;\n  }\n\n  get message(): string | undefined {\n    return this.#message;\n  }\n\n  override get type(): 'error' {\n    return 'error';\n  }\n}\n","import FakeArray from './private/FakeArray';\nimport type SpeechRecognitionResult from './SpeechRecognitionResult';\n\nexport default class SpeechRecognitionResultList extends FakeArray<SpeechRecognitionResult> {\n  constructor(result: readonly SpeechRecognitionResult[]) {\n    super(result);\n  }\n}\n","import SpeechRecognitionResultList from './SpeechRecognitionResultList';\n\nexport type SpeechRecognitionEventInit = {\n  data?: undefined | unknown;\n  resultIndex?: number | undefined;\n  results?: SpeechRecognitionResultList | undefined;\n};\n\nexport default class SpeechRecognitionEvent<\n  T extends\n    | 'audioend'\n    | 'audiostart'\n    | 'cognitiveservices'\n    | 'end'\n    | 'result'\n    | 'soundend'\n    | 'soundstart'\n    | 'speechend'\n    | 'speechstart'\n    | 'start'\n> extends Event {\n  constructor(type: 'cognitiveservices', init: SpeechRecognitionEventInit & { data: { type: string } });\n  constructor(type: 'audioend');\n  constructor(type: 'audiostart');\n  constructor(type: 'end');\n  constructor(type: 'result', init: SpeechRecognitionEventInit);\n  constructor(type: 'soundend');\n  constructor(type: 'soundstart');\n  constructor(type: 'speechend');\n  constructor(type: 'speechstart');\n  constructor(type: 'start');\n\n  constructor(type: T, { data, resultIndex, results }: SpeechRecognitionEventInit = {}) {\n    super(type);\n\n    this.#data = data;\n    this.#resultIndex = resultIndex;\n    this.#results = results || new SpeechRecognitionResultList([]);\n  }\n\n  #data: undefined | unknown;\n  // TODO: \"resultIndex\" should be set.\n  #resultIndex: number | undefined;\n  #results: SpeechRecognitionResultList;\n\n  get data(): unknown {\n    return this.#data;\n  }\n\n  get resultIndex(): number | undefined {\n    return this.#resultIndex;\n  }\n\n  get results(): SpeechRecognitionResultList {\n    return this.#results;\n  }\n\n  override get type(): T {\n    return super.type as T;\n  }\n}\n","/* eslint class-methods-use-this: 0 */\n\nimport { EventTarget, getEventAttributeValue, setEventAttributeValue } from 'event-target-shim';\nimport { onErrorResumeNext } from 'on-error-resume-next/async';\nimport createDeferred from 'p-defer';\n\nimport patchOptions from '../patchOptions';\nimport AudioContextQueue from './AudioContextQueue';\nimport SpeechSynthesisEvent from './SpeechSynthesisEvent';\nimport SpeechSynthesisUtterance from './SpeechSynthesisUtterance';\nimport fetchCustomVoices from './fetchCustomVoices';\nimport fetchVoices from './fetchVoices';\n\n// Supported output format can be found at https://docs.microsoft.com/en-us/azure/cognitive-services/speech-service/rest-text-to-speech#audio-outputs\nconst DEFAULT_OUTPUT_FORMAT = 'audio-24khz-160kbitrate-mono-mp3';\nconst EMPTY_ARRAY = [];\n\nexport default options => {\n  const {\n    audioContext,\n    fetchCredentials,\n    ponyfill = {\n      AudioContext: window.AudioContext || window.webkitAudioContext\n    },\n    speechSynthesisDeploymentId,\n    speechSynthesisOutputFormat = DEFAULT_OUTPUT_FORMAT\n  } = patchOptions(options);\n\n  if (!audioContext && !ponyfill.AudioContext) {\n    console.warn(\n      'web-speech-cognitive-services: This browser does not support Web Audio and it will not work with Cognitive Services Speech Services.'\n    );\n\n    return {};\n  }\n\n  class SpeechSynthesis extends EventTarget {\n    constructor() {\n      super();\n\n      this.queue = new AudioContextQueue({ audioContext, ponyfill });\n\n      this.updateVoices();\n    }\n\n    cancel() {\n      this.queue.stop();\n    }\n\n    getVoices() {\n      return EMPTY_ARRAY;\n    }\n\n    get onvoiceschanged() {\n      return getEventAttributeValue(this, 'voiceschanged');\n    }\n\n    set onvoiceschanged(value) {\n      setEventAttributeValue(this, 'voiceschanged', value);\n    }\n\n    pause() {\n      this.queue.pause();\n    }\n\n    resume() {\n      this.queue.resume();\n    }\n\n    speak(utterance) {\n      if (!(utterance instanceof SpeechSynthesisUtterance)) {\n        throw new Error('invalid utterance');\n      }\n\n      const { reject, resolve, promise } = createDeferred();\n      const handleError = ({ error: errorCode, message }) => {\n        const error = new Error(errorCode);\n\n        error.stack = message;\n\n        reject(error);\n      };\n\n      utterance.addEventListener('end', resolve);\n      utterance.addEventListener('error', handleError);\n\n      utterance.preload({\n        deploymentId: speechSynthesisDeploymentId,\n        fetchCredentials,\n        outputFormat: speechSynthesisOutputFormat\n      });\n\n      this.queue.push(utterance);\n\n      return promise.finally(() => {\n        utterance.removeEventListener('end', resolve);\n        utterance.removeEventListener('error', handleError);\n      });\n    }\n\n    get speaking() {\n      return this.queue.speaking;\n    }\n\n    async updateVoices() {\n      const { customVoiceHostname, region, speechSynthesisHostname, subscriptionKey } = await fetchCredentials();\n\n      if (speechSynthesisDeploymentId) {\n        if (subscriptionKey) {\n          console.warn(\n            'web-speech-cognitive-services: Listing of custom voice models are only available when using subscription key.'\n          );\n\n          await onErrorResumeNext(async () => {\n            const voices = await fetchCustomVoices({\n              customVoiceHostname,\n              deploymentId: speechSynthesisDeploymentId,\n              region,\n              speechSynthesisHostname,\n              subscriptionKey\n            });\n\n            this.getVoices = () => voices;\n          });\n        }\n      } else {\n        // If fetch voice list failed, we will not emit \"voiceschanged\" event.\n        // In the spec, there is no \"error\" event.\n\n        await onErrorResumeNext(async () => {\n          const voices = await fetchVoices(await fetchCredentials());\n\n          this.getVoices = () => voices;\n        });\n      }\n\n      this.dispatchEvent(new SpeechSynthesisEvent('voiceschanged'));\n    }\n  }\n\n  return {\n    speechSynthesis: new SpeechSynthesis(),\n    SpeechSynthesisEvent,\n    SpeechSynthesisUtterance\n  };\n};\n","/* eslint no-await-in-loop: \"off\" */\n\nimport memoize from 'memoize-one';\n\nimport AudioContextConsumer from './AudioContextConsumer';\n\nexport default class {\n  constructor({ audioContext, ponyfill }) {\n    this.consumer = null;\n    this.paused = false;\n    this.queue = [];\n\n    this.getAudioContext = memoize(() => audioContext || new ponyfill.AudioContext());\n  }\n\n  pause() {\n    this.paused = true;\n    this.consumer && this.consumer.pause();\n  }\n\n  push(utterance) {\n    this.queue.push(utterance);\n    this.startConsumer();\n  }\n\n  resume() {\n    this.paused = false;\n\n    if (this.consumer) {\n      this.consumer.resume();\n    } else {\n      this.startConsumer();\n    }\n  }\n\n  get speaking() {\n    return !!this.consumer;\n  }\n\n  async startConsumer() {\n    while (!this.paused && this.queue.length && !this.consumer) {\n      this.consumer = new AudioContextConsumer(this.getAudioContext());\n\n      await this.consumer.start(this.queue);\n\n      this.consumer = null;\n    }\n  }\n\n  stop() {\n    this.queue.splice(0);\n    this.consumer && this.consumer.stop();\n  }\n}\n","/* eslint no-await-in-loop: \"off\" */\n\nexport default class {\n  constructor(audioContext) {\n    this.audioContext = audioContext;\n  }\n\n  pause() {\n    this.audioContext && this.audioContext.suspend();\n    this.playingUtterance && this.playingUtterance.dispatchEvent(new CustomEvent('pause'));\n  }\n\n  resume() {\n    this.audioContext && this.audioContext.resume();\n    this.playingUtterance && this.playingUtterance.dispatchEvent(new CustomEvent('resume'));\n  }\n\n  async start(queue) {\n    let utterance;\n\n    while ((utterance = queue.shift())) {\n      this.playingUtterance = utterance;\n\n      await utterance.play(this.audioContext);\n\n      this.playingUtterance = null;\n    }\n  }\n\n  stop() {\n    this.playingUtterance && this.playingUtterance.stop();\n\n    if (this.audioContext.state === 'suspended') {\n      // Play -> Pause -> Cancel (stop)\n      // This would generate these events: \"start\", \"pause\", \"end\"\n\n      // Without this code, the \"end\" event will not emit until resume() is called\n      // Cancelling an unstarted utterance will not emit any \"start\" or \"end\" event\n      this.audioContext.resume();\n    }\n  }\n}\n","import { Event } from 'event-target-shim';\n\nexport default class SpeechSynthesisEvent extends Event {\n  constructor(type) {\n    super(type);\n  }\n}\n","/* eslint no-empty: [\"error\", { \"allowEmptyCatch\": true }] */\n\nimport { EventAsPromise } from 'event-as-promise';\nimport { EventTarget, getEventAttributeValue, setEventAttributeValue } from 'event-target-shim';\n\nimport fetchSpeechData from './fetchSpeechData';\nimport SpeechSynthesisEvent from './SpeechSynthesisEvent';\nimport subscribeEvent from './subscribeEvent';\n\nfunction asyncDecodeAudioData(audioContext, arrayBuffer) {\n  return new Promise((resolve, reject) => {\n    const promise = audioContext.decodeAudioData(arrayBuffer, resolve, reject);\n\n    // Newer implementation of \"decodeAudioData\" will return a Promise\n    promise && typeof promise.then === 'function' && resolve(promise);\n  });\n}\n\nfunction playDecoded(audioContext, audioBuffer, source) {\n  return new Promise((resolve, reject) => {\n    const audioContextClosed = new EventAsPromise();\n    const sourceEnded = new EventAsPromise();\n    const unsubscribe = subscribeEvent(\n      audioContext,\n      'statechange',\n      ({ target: { state } }) => state === 'closed' && audioContextClosed.eventListener()\n    );\n\n    try {\n      source.buffer = audioBuffer;\n      // \"ended\" may not fire if the underlying AudioContext is closed prematurely\n      source.onended = sourceEnded.eventListener;\n\n      source.connect(audioContext.destination);\n      source.start(0);\n\n      Promise.race([audioContextClosed.upcoming(), sourceEnded.upcoming()]).then(resolve);\n    } catch (err) {\n      reject(err);\n    } finally {\n      unsubscribe();\n    }\n  });\n}\n\nclass SpeechSynthesisUtterance extends EventTarget {\n  constructor(text) {\n    super();\n\n    this._lang = null;\n    this._pitch = 1;\n    this._rate = 1;\n    this._voice = null;\n    this._volume = 1;\n\n    this.text = text;\n\n    this.onboundary = null;\n    this.onend = null;\n    this.onerror = null;\n    this.onmark = null;\n    this.onpause = null;\n    this.onresume = null;\n    this.onstart = null;\n  }\n\n  get lang() {\n    return this._lang;\n  }\n\n  set lang(value) {\n    this._lang = value;\n  }\n\n  get onboundary() {\n    return getEventAttributeValue(this, 'boundary');\n  }\n\n  set onboundary(value) {\n    setEventAttributeValue(this, 'boundary', value);\n  }\n\n  get onend() {\n    return getEventAttributeValue(this, 'end');\n  }\n\n  set onend(value) {\n    setEventAttributeValue(this, 'end', value);\n  }\n\n  get onerror() {\n    return getEventAttributeValue(this, 'error');\n  }\n\n  set onerror(value) {\n    setEventAttributeValue(this, 'error', value);\n  }\n\n  get onmark() {\n    return getEventAttributeValue(this, 'mark');\n  }\n\n  set onmark(value) {\n    setEventAttributeValue(this, 'mark', value);\n  }\n\n  get onpause() {\n    return getEventAttributeValue(this, 'pause');\n  }\n\n  set onpause(value) {\n    setEventAttributeValue(this, 'pause', value);\n  }\n\n  get onresume() {\n    return getEventAttributeValue(this, 'resume');\n  }\n\n  set onresume(value) {\n    setEventAttributeValue(this, 'resume', value);\n  }\n\n  get onstart() {\n    return getEventAttributeValue(this, 'start');\n  }\n\n  set onstart(value) {\n    setEventAttributeValue(this, 'start', value);\n  }\n\n  get pitch() {\n    return this._pitch;\n  }\n\n  set pitch(value) {\n    this._pitch = value;\n  }\n\n  get rate() {\n    return this._rate;\n  }\n\n  set rate(value) {\n    this._rate = value;\n  }\n\n  get voice() {\n    return this._voice;\n  }\n\n  set voice(value) {\n    this._voice = value;\n  }\n\n  get volume() {\n    return this._volume;\n  }\n\n  set volume(value) {\n    this._volume = value;\n  }\n\n  preload({ deploymentId, fetchCredentials, outputFormat }) {\n    this.arrayBufferPromise = fetchSpeechData({\n      fetchCredentials,\n      deploymentId,\n      lang: this.lang || window.navigator.language,\n      outputFormat,\n      pitch: this.pitch,\n      rate: this.rate,\n      text: this.text,\n      voice: this.voice && this.voice.voiceURI,\n      volume: this.volume\n    });\n\n    // We need to call \"catch\" to make sure the Promise is running.\n    // We will ignore the reject result and handled in play() later.\n    this.arrayBufferPromise.catch();\n  }\n\n  async play(audioContext) {\n    try {\n      // We should emit \"start\" event even if preload() failed.\n      this.dispatchEvent(new SpeechSynthesisEvent('start'));\n\n      // HACK: iOS requires bufferSourceNode to be constructed before decoding data.\n      const source = audioContext.createBufferSource();\n      const audioBuffer = await asyncDecodeAudioData(audioContext, await this.arrayBufferPromise);\n\n      this._playingSource = source;\n\n      await playDecoded(audioContext, audioBuffer, source);\n\n      this._playingSource = null;\n      this.dispatchEvent(new SpeechSynthesisEvent('end'));\n    } catch (error) {\n      // \"message\" is not in spec but to provide a friendly message.\n      this.dispatchEvent(new ErrorEvent('error', { error: 'synthesis-failed', message: error.stack }));\n    }\n  }\n\n  stop() {\n    this._playingSource && this._playingSource.stop();\n  }\n}\n\nexport default SpeechSynthesisUtterance;\n","import { decode } from 'base64-arraybuffer';\nimport buildSSML from './buildSSML';\nimport isSSML from './isSSML';\n\nconst DEFAULT_LANGUAGE = 'en-US';\nconst DEFAULT_OUTPUT_FORMAT = 'riff-16khz-16bit-mono-pcm';\nconst DEFAULT_VOICE = 'Microsoft Server Speech Text to Speech Voice (en-US, AriaNeural)';\nconst EMPTY_MP3_BASE64 =\n  'SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU3LjU2LjEwMQAAAAAAAAAAAAAA//tAwAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAACAAABhgC7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7//////////////////////////////////////////////////////////////////8AAAAATGF2YzU3LjY0AAAAAAAAAAAAAAAAJAUHAAAAAAAAAYYoRBqpAAAAAAD/+xDEAAPAAAGkAAAAIAAANIAAAARMQU1FMy45OS41VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7EMQpg8AAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV';\n\nexport default async function ({\n  deploymentId,\n  fetchCredentials,\n  lang = DEFAULT_LANGUAGE,\n  outputFormat = DEFAULT_OUTPUT_FORMAT,\n  pitch,\n  rate,\n  text,\n  voice = DEFAULT_VOICE,\n  volume\n}) {\n  if (!text) {\n    // If text is empty, play a short audio clip. This allows developers to easily prime the AudioContext object by playing an empty string.\n    return decode(EMPTY_MP3_BASE64);\n  }\n\n  const { authorizationToken, region, speechSynthesisHostname, subscriptionKey } = await fetchCredentials();\n\n  if ((authorizationToken && subscriptionKey) || (!authorizationToken && !subscriptionKey)) {\n    throw new Error('Only \"authorizationToken\" or \"subscriptionKey\" should be set.');\n  } else if ((region && speechSynthesisHostname) || (!region && !speechSynthesisHostname)) {\n    throw new Error('Only \"region\" or \"speechSynthesisHostnamename\" should be set.');\n  }\n\n  const ssml = isSSML(text) ? text : buildSSML({ lang, pitch, rate, text, voice, volume });\n\n  // Although calling encodeURI on hostname does not actually works, it fails faster and safer.\n  const hostname =\n    speechSynthesisHostname ||\n    (deploymentId\n      ? `${encodeURI(region)}.voice.speech.microsoft.com`\n      : `${encodeURI(region)}.tts.speech.microsoft.com`);\n  const search = deploymentId ? `?deploymentId=${encodeURI(deploymentId)}` : '';\n  const url = `https://${hostname}/cognitiveservices/v1${search}`;\n\n  const res = await fetch(url, {\n    headers: {\n      'Content-Type': 'application/ssml+xml',\n      'X-Microsoft-OutputFormat': outputFormat,\n      ...(authorizationToken\n        ? {\n            Authorization: `Bearer ${authorizationToken}`\n          }\n        : {\n            'Ocp-Apim-Subscription-Key': subscriptionKey\n          })\n    },\n    method: 'POST',\n    body: ssml\n  });\n\n  if (!res.ok) {\n    throw new Error(`web-speech-cognitive-services: Failed to syntheis speech, server returned ${res.status}`);\n  }\n\n  return res.arrayBuffer();\n}\n","/* eslint no-magic-numbers: [\"error\", { \"ignore\": [0, 1, 100] }] */\n\n// Cognitive Services does not support unsigned percentage\n// It must be converted into +/- first.\nfunction relativePercentage(value) {\n  let relative = Math.round((value - 1) * 100);\n\n  if (relative >= 0) {\n    relative = '+' + relative;\n  }\n\n  return relative + '%';\n}\n\nexport default function buildSSML({ lang, pitch = 1, rate = 1, text, voice, volume }) {\n  return `<speak version=\"1.0\" xml:lang=\"${lang}\">\n  <voice xml:lang=\"${lang}\" name=\"${voice}\">\n    <prosody pitch=\"${relativePercentage(pitch)}\" rate=\"${relativePercentage(rate)}\" volume=\"${relativePercentage(\n      volume\n    )}\">\n      ${text}\n    </prosody>\n  </voice>\n</speak>`;\n}\n","const SPEAK_TAG_PATTERN = /^\\s*<speak(\\s|\\/?>)/u;\nconst XML_PROLOG_PATTERN = /^\\s*<\\?xml\\s/u;\n\nexport default function isSSML(text) {\n  return SPEAK_TAG_PATTERN.test(text) || XML_PROLOG_PATTERN.test(text);\n}\n","export default function subscribeEvent(target, name, handler) {\n  target.addEventListener(name, handler);\n\n  return () => target.removeEventListener(name, handler);\n}\n","export default class {\n  constructor({ gender, lang, voiceURI }) {\n    this._default = false;\n    this._gender = gender;\n    this._lang = lang;\n    this._localService = false;\n    this._name = voiceURI;\n    this._voiceURI = voiceURI;\n  }\n\n  get default() {\n    return this._default;\n  }\n\n  get gender() {\n    return this._gender;\n  }\n\n  get lang() {\n    return this._lang;\n  }\n\n  get localService() {\n    return this._localService;\n  }\n\n  get name() {\n    return this._name;\n  }\n\n  get voiceURI() {\n    return this._voiceURI;\n  }\n}\n","/* eslint no-magic-numbers: [\"error\", { \"ignore\": [0, 1, -1] }] */\n\nimport SpeechSynthesisVoice from './SpeechSynthesisVoice';\n\nasync function fetchCustomVoices({ customVoiceHostname, deploymentId, region, subscriptionKey }) {\n  const hostname = customVoiceHostname || `${region}.customvoice.api.speech.microsoft.com`;\n\n  // Although encodeURI on a hostname doesn't work as expected for hostname, at least, it will fail peacefully.\n  const res = await fetch(\n    `https://${encodeURI(hostname)}/api/texttospeech/v2.0/endpoints/${encodeURIComponent(deploymentId)}`,\n    {\n      headers: {\n        accept: 'application/json',\n        'ocp-apim-subscription-key': subscriptionKey\n      }\n    }\n  );\n\n  if (!res.ok) {\n    throw new Error('Failed to fetch custom voices');\n  }\n\n  return res.json();\n}\n\nexport default async function ({ customVoiceHostname, deploymentId, region, subscriptionKey }) {\n  const { models } = await fetchCustomVoices({ customVoiceHostname, deploymentId, region, subscriptionKey });\n\n  return models\n    .map(\n      ({ properties: { Gender: gender }, locale: lang, name: voiceURI }) =>\n        new SpeechSynthesisVoice({ gender, lang, voiceURI })\n    )\n    .sort(({ name: x }, { name: y }) => (x > y ? 1 : x < y ? -1 : 0));\n}\n","/* eslint no-magic-numbers: [\"error\", { \"ignore\": [0, 1, -1] }] */\n\nimport SpeechSynthesisVoice from './SpeechSynthesisVoice';\n\nexport default async function fetchVoices({ authorizationToken, region, speechSynthesisHostname, subscriptionKey }) {\n  // Although encodeURI on a hostname doesn't work as expected for hostname, at least, it will fail peacefully.\n  const hostname = speechSynthesisHostname || `${encodeURI(region)}.tts.speech.microsoft.com`;\n  const res = await fetch(`https://${hostname}/cognitiveservices/voices/list`, {\n    headers: {\n      'content-type': 'application/json',\n      ...(authorizationToken\n        ? {\n            authorization: `Bearer ${authorizationToken}`\n          }\n        : {\n            'Ocp-Apim-Subscription-Key': subscriptionKey\n          })\n    }\n  });\n\n  if (!res.ok) {\n    throw new Error('Failed to fetch voices');\n  }\n\n  const voices = await res.json();\n\n  return voices\n    .map(({ Gender: gender, Locale: lang, Name: voiceURI }) => new SpeechSynthesisVoice({ gender, lang, voiceURI }))\n    .sort(({ name: x }, { name: y }) => (x > y ? 1 : x < y ? -1 : 0));\n}\n","import createSpeechSynthesisPonyfill from './TextToSpeech/createSpeechSynthesisPonyfill';\n\nexport default createSpeechSynthesisPonyfill;\n","const TOKEN_URL_TEMPLATE = 'https://{region}.api.cognitive.microsoft.com/sts/v1.0/issueToken';\n\ntype FetchAuthorizationTokenInit = {\n  region: string;\n  subscriptionKey: string;\n};\n\nexport default async function fetchAuthorizationToken({\n  region,\n  subscriptionKey\n}: FetchAuthorizationTokenInit): Promise<string> {\n  const res = await fetch(TOKEN_URL_TEMPLATE.replace(/\\{region\\}/u, region), {\n    headers: {\n      'Ocp-Apim-Subscription-Key': subscriptionKey\n    },\n    method: 'POST'\n  });\n\n  if (!res.ok) {\n    throw new Error(`Failed to fetch authorization token, server returned ${res.status}`);\n  }\n\n  return res.text();\n}\n","/* global process */\n\nimport {\n  createSpeechRecognitionPonyfill,\n  createSpeechRecognitionPonyfillFromRecognizer,\n  type SpeechGrammarList,\n  type SpeechRecognitionAlternative,\n  type SpeechRecognitionErrorEvent,\n  type SpeechRecognitionEvent,\n  type SpeechRecognitionEventListenerMap,\n  type SpeechRecognitionResult,\n  type SpeechRecognitionResultList\n} from './SpeechServices/SpeechToText';\nimport createSpeechSynthesisPonyfill from './SpeechServices/TextToSpeech';\nimport fetchAuthorizationToken from './SpeechServices/fetchAuthorizationToken';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport default function createSpeechServicesPonyfill(options: any = {}): any {\n  return {\n    ...createSpeechRecognitionPonyfill(options),\n    ...createSpeechSynthesisPonyfill(options)\n  };\n}\n\nexport {\n  createSpeechRecognitionPonyfill,\n  createSpeechRecognitionPonyfillFromRecognizer,\n  createSpeechSynthesisPonyfill,\n  fetchAuthorizationToken,\n  type SpeechGrammarList,\n  type SpeechRecognitionAlternative,\n  type SpeechRecognitionErrorEvent,\n  type SpeechRecognitionEvent,\n  type SpeechRecognitionEventListenerMap,\n  type SpeechRecognitionResult,\n  type SpeechRecognitionResultList\n};\n\nconst meta = document.createElement('meta');\n\nmeta.setAttribute('name', 'web-speech-cognitive-services');\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nmeta.setAttribute('content', `version=${process.env.npm_package_version}`);\n\ndocument.head.appendChild(meta);\n"],"mappings":"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","names":["import_valibot","import_valibot","import_valibot","import_valibot","import_valibot","import_valibot","import_valibot","AudioConfig","import_valibot","array","array","averageAmplitude","ResultReason","SpeechRecognizer","enableTelemetrySchema","OutputFormat","SpeechConfig","SpeechRecognizer","import_event_target_shim","memoize","import_event_target_shim","DEFAULT_OUTPUT_FORMAT"]}